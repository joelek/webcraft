/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/client/index.js":
/*!*******************************!*\
  !*** ./build/client/index.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst shared = __webpack_require__(/*! ../shared */ \"./build/shared/index.js\");\r\nvar is;\r\n(function (is) {\r\n    function absent(subject) {\r\n        return subject == null;\r\n    }\r\n    is.absent = absent;\r\n    ;\r\n    function present(subject) {\r\n        return subject != null;\r\n    }\r\n    is.present = present;\r\n    ;\r\n})(is || (is = {}));\r\n;\r\nvar assert;\r\n(function (assert_1) {\r\n    function assert(assertion) {\r\n        if (!assertion) {\r\n            throw `Assertion failed!`;\r\n        }\r\n    }\r\n    assert_1.assert = assert;\r\n    function between(min, value, max) {\r\n        if ((value < min) || (value > max)) {\r\n            throw `Expected ${value} to be an integer between ${min} and ${max}!`;\r\n        }\r\n    }\r\n    assert_1.between = between;\r\n    function identical(one, two) {\r\n        if (one !== two) {\r\n            throw `Expected ${one} to be identical to ${two}!`;\r\n        }\r\n    }\r\n    assert_1.identical = identical;\r\n})(assert || (assert = {}));\r\nclass BufferLike {\r\n    constructor(buffer, endianness = \"BigEndian\") {\r\n        this.buffer = buffer;\r\n        this.endianness = endianness;\r\n    }\r\n    ui16(offset, endianness = this.endianness) {\r\n        return new ui16(endianness, this.buffer, offset);\r\n    }\r\n}\r\nclass BufferDataProvider {\r\n    constructor(buffer) {\r\n        this.buffer = buffer;\r\n    }\r\n    read(cursor, buffer, offset, length) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            offset = offset !== null && offset !== void 0 ? offset : 0;\r\n            length = length !== null && length !== void 0 ? length : (buffer.byteLength - offset);\r\n            let slice = this.buffer.slice(cursor, cursor + length);\r\n            let source = new Uint8Array(slice);\r\n            let target = new Uint8Array(buffer, offset, length);\r\n            target.set(source, 0);\r\n            return length;\r\n        });\r\n    }\r\n    size() {\r\n        return this.buffer.byteLength;\r\n    }\r\n}\r\nclass FileDataProvider {\r\n    constructor(file) {\r\n        this.file = file;\r\n    }\r\n    buffer() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let buffer = new ArrayBuffer(this.size());\r\n            yield this.read(0, buffer);\r\n            return new BufferDataProvider(buffer);\r\n        });\r\n    }\r\n    read(cursor, buffer, offset, length) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            offset = offset !== null && offset !== void 0 ? offset : 0;\r\n            length = length !== null && length !== void 0 ? length : (buffer.byteLength - offset);\r\n            assert.between(0, offset, buffer.byteLength);\r\n            assert.between(0, length, buffer.byteLength - offset);\r\n            let blob = this.file.slice(cursor, cursor + length);\r\n            let source = new Uint8Array(yield blob.arrayBuffer());\r\n            let target = new Uint8Array(buffer, offset, length);\r\n            target.set(source, 0);\r\n            return length;\r\n        });\r\n    }\r\n    size() {\r\n        return this.file.size;\r\n    }\r\n}\r\nclass si08 {\r\n    constructor(endianness, buffer = new ArrayBuffer(1), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 1);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 1);\r\n    }\r\n    get value() {\r\n        return this.view.getInt8(0);\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.setInt8(0, next);\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass si16 {\r\n    constructor(endianness, buffer = new ArrayBuffer(2), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 2);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 2);\r\n    }\r\n    get value() {\r\n        return this.view.getInt16(0, this.endianness === \"LittleEndian\");\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.setUint16(0, next, this.endianness === \"LittleEndian\");\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass si24 {\r\n    constructor(endianness, buffer = new ArrayBuffer(3), offset = 0) {\r\n        this.integer = new ui24(endianness, buffer, offset);\r\n    }\r\n    get value() {\r\n        let value = this.integer.value;\r\n        if (value > 0x7FFFFF) {\r\n            value -= 0x1000000;\r\n        }\r\n        return value;\r\n    }\r\n    set value(next) {\r\n        if (next < 0) {\r\n            next += 0x1000000;\r\n        }\r\n        this.integer.value = next;\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.integer.load(cursor, dataProvider);\r\n        });\r\n    }\r\n}\r\nclass si32 {\r\n    constructor(endianness, buffer = new ArrayBuffer(4), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 4);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 4);\r\n    }\r\n    get value() {\r\n        return this.view.getInt32(0, this.endianness === \"LittleEndian\");\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.setInt32(0, next, this.endianness === \"LittleEndian\");\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass ui08 {\r\n    constructor(endianness, buffer = new ArrayBuffer(1), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 1);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 1);\r\n    }\r\n    get value() {\r\n        return this.view.getUint8(0);\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.setUint8(0, next);\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass ui16 {\r\n    constructor(endianness, buffer = new ArrayBuffer(2), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 2);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 2);\r\n    }\r\n    get value() {\r\n        return this.view.getUint16(0, this.endianness === \"LittleEndian\");\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.setUint16(0, next, this.endianness === \"LittleEndian\");\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass ui24 {\r\n    constructor(endianness, buffer = new ArrayBuffer(3), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 3);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 3);\r\n    }\r\n    get value() {\r\n        let a = this.view.getUint8(0);\r\n        let b = this.view.getUint8(1);\r\n        let c = this.view.getUint8(2);\r\n        if (this.endianness === \"LittleEndian\") {\r\n            return (c << 16) | (b << 8) | (a << 0);\r\n        }\r\n        else {\r\n            return (a << 16) | (b << 8) | (c << 0);\r\n        }\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        let a = (next >>> 0) & 0xFF;\r\n        let b = (next >>> 8) & 0xFF;\r\n        let c = (next >>> 16) & 0xFF;\r\n        if (this.endianness === \"LittleEndian\") {\r\n            this.view.setUint8(0, a);\r\n            this.view.setUint8(1, b);\r\n            this.view.setUint8(2, c);\r\n        }\r\n        else {\r\n            this.view.setUint8(0, c);\r\n            this.view.setUint8(1, b);\r\n            this.view.setUint8(2, a);\r\n        }\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass ui32 {\r\n    constructor(endianness, buffer = new ArrayBuffer(4), offset = 0) {\r\n        assert.between(0, offset, buffer.byteLength - 4);\r\n        this.endianness = endianness;\r\n        this.view = new DataView(buffer, offset, 4);\r\n    }\r\n    get value() {\r\n        return this.view.getUint32(0, this.endianness === \"LittleEndian\");\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.setUint32(0, next, this.endianness === \"LittleEndian\");\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass pi08 {\r\n    constructor(integer, offset, length) {\r\n        assert.between(0, offset, 8 - 1);\r\n        assert.between(1, length, 8 - offset);\r\n        this.integer = integer;\r\n        this.offset = offset;\r\n        this.length = length;\r\n    }\r\n    get value() {\r\n        let a = 32 - (this.offset + this.length);\r\n        let b = 32 - (this.length);\r\n        return (this.integer.value << a) >>> b;\r\n    }\r\n    set value(next) {\r\n        let last = this.integer.value;\r\n        let a = this.offset;\r\n        let b = 32 - (this.length);\r\n        let c = 32 - (this.offset + this.length);\r\n        let m = ((0xFFFFFFFF >> a) << b) >>> c;\r\n        this.integer.value = ((this.integer.value & ~m) | ((next << a) & m)) >>> 0;\r\n        if (this.value !== next) {\r\n            this.integer.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n}\r\nclass pi16 {\r\n    constructor(integer, offset, length) {\r\n        assert.between(0, offset, 16 - 1);\r\n        assert.between(1, length, 16 - offset);\r\n        this.integer = integer;\r\n        this.offset = offset;\r\n        this.length = length;\r\n    }\r\n    get value() {\r\n        let a = 32 - (this.offset + this.length);\r\n        let b = 32 - (this.length);\r\n        return (this.integer.value << a) >>> b;\r\n    }\r\n    set value(next) {\r\n        let last = this.integer.value;\r\n        let a = this.offset;\r\n        let b = 32 - (this.length);\r\n        let c = 32 - (this.offset + this.length);\r\n        let m = ((0xFFFFFFFF >> a) << b) >>> c;\r\n        this.integer.value = ((this.integer.value & ~m) | ((next << a) & m)) >>> 0;\r\n        if (this.value !== next) {\r\n            this.integer.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n}\r\nclass pi24 {\r\n    constructor(integer, offset, length) {\r\n        assert.between(0, offset, 24 - 1);\r\n        assert.between(1, length, 24 - offset);\r\n        this.integer = integer;\r\n        this.offset = offset;\r\n        this.length = length;\r\n    }\r\n    get value() {\r\n        let a = 32 - (this.offset + this.length);\r\n        let b = 32 - (this.length);\r\n        return (this.integer.value << a) >>> b;\r\n    }\r\n    set value(next) {\r\n        let last = this.integer.value;\r\n        let a = this.offset;\r\n        let b = 32 - (this.length);\r\n        let c = 32 - (this.offset + this.length);\r\n        let m = ((0xFFFFFFFF >> a) << b) >>> c;\r\n        this.integer.value = ((this.integer.value & ~m) | ((next << a) & m)) >>> 0;\r\n        if (this.value !== next) {\r\n            this.integer.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n}\r\nclass pi32 {\r\n    constructor(integer, offset, length) {\r\n        assert.between(0, offset, 32 - 1);\r\n        assert.between(1, length, 32 - offset);\r\n        this.integer = integer;\r\n        this.offset = offset;\r\n        this.length = length;\r\n    }\r\n    get value() {\r\n        let a = 32 - (this.offset + this.length);\r\n        let b = 32 - (this.length);\r\n        return (this.integer.value << a) >>> b;\r\n    }\r\n    set value(next) {\r\n        let last = this.integer.value;\r\n        let a = this.offset;\r\n        let b = 32 - (this.length);\r\n        let c = 32 - (this.offset + this.length);\r\n        let m = ((0xFFFFFFFF >> a) << b) >>> c;\r\n        this.integer.value = ((this.integer.value & ~m) | ((next << a) & m)) >>> 0;\r\n        if (this.value !== next) {\r\n            this.integer.value = last;\r\n            throw `Unexpectedly encoded ${next} as ${this.value}!`;\r\n        }\r\n    }\r\n}\r\nclass text {\r\n    constructor(buffer, offset, length) {\r\n        offset = offset !== null && offset !== void 0 ? offset : 0;\r\n        length = length !== null && length !== void 0 ? length : (buffer.byteLength - offset);\r\n        assert.between(0, offset, buffer.byteLength);\r\n        assert.between(0, length, buffer.byteLength - offset);\r\n        this.decoder = new TextDecoder();\r\n        this.encoder = new TextEncoder();\r\n        this.view = new Uint8Array(buffer, offset, length);\r\n    }\r\n    get value() {\r\n        return this.decoder.decode(this.view).replace(/([\\u0000]*)$/, \"\");\r\n    }\r\n    set value(next) {\r\n        let last = this.value;\r\n        this.view.fill(0);\r\n        this.encoder.encodeInto(next, this.view);\r\n        if (this.value !== next) {\r\n            this.value = last;\r\n            throw `Unexpectedly encoded \"${next}\" as \"${this.value}\"!`;\r\n        }\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.view.buffer, this.view.byteOffset, this.view.byteLength);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass ArchiveHeader {\r\n    constructor(endianness) {\r\n        this.buffer = new ArrayBuffer(8);\r\n        this.version = new ui32(endianness, this.buffer, 0);\r\n        this.recordCount = new ui32(endianness, this.buffer, 4);\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.buffer);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass RecordHeader {\r\n    constructor(endianness) {\r\n        this.buffer = new ArrayBuffer(4);\r\n        let integer = new ui32(endianness, this.buffer, 0);\r\n        this.uncompressedSize = new pi32(integer, 0, 24);\r\n        this.isCompressed = new pi32(integer, 29, 1);\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.buffer);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass Archive {\r\n    constructor(dataProvider, endianness) {\r\n        this.dataProvider = dataProvider;\r\n        this.endianness = endianness;\r\n    }\r\n    decompress(cursor, buffer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let array = new Uint8Array(buffer);\r\n            let shift = 8;\r\n            let bytesWritten = 0;\r\n            let control = new Uint8Array(1);\r\n            let byte = new Uint8Array(1);\r\n            let history = new Uint8Array(1 << 12);\r\n            let historyPosition = 0;\r\n            function append(byte) {\r\n                history[historyPosition] = byte;\r\n                historyPosition += 1;\r\n                historyPosition %= (1 << 12);\r\n                array[bytesWritten] = byte;\r\n                bytesWritten += 1;\r\n            }\r\n            let data = new ui16(this.endianness);\r\n            let dataOffset = new pi16(data, 0, 12);\r\n            let dataLength = new pi16(data, 12, 4);\r\n            while (bytesWritten < buffer.byteLength) {\r\n                if (shift >= 8) {\r\n                    cursor += yield this.dataProvider.read(cursor, control.buffer);\r\n                    shift = 0;\r\n                }\r\n                let bit = (control[0] >> shift) & 0x01;\r\n                shift += 1;\r\n                if (bit) {\r\n                    cursor += yield this.dataProvider.read(cursor, byte.buffer);\r\n                    append(byte[0]);\r\n                }\r\n                else {\r\n                    cursor += yield data.load(cursor, this.dataProvider);\r\n                    let offset = dataOffset.value;\r\n                    let length = dataLength.value + 3;\r\n                    for (let i = offset; i < offset + length; i++) {\r\n                        append(history[i % (1 << 12)]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getRecord(index) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let archiveHeader = new ArchiveHeader(this.endianness);\r\n            let cursor = 0;\r\n            cursor += yield archiveHeader.load(cursor, this.dataProvider);\r\n            assert.between(0, index, archiveHeader.recordCount.value - 1);\r\n            cursor += index * 4;\r\n            let offset = new ui32(this.endianness);\r\n            cursor += yield offset.load(cursor, this.dataProvider);\r\n            let recordHeader = new RecordHeader(this.endianness);\r\n            cursor = offset.value;\r\n            cursor += yield recordHeader.load(cursor, this.dataProvider);\r\n            let buffer = new ArrayBuffer(recordHeader.uncompressedSize.value);\r\n            if (recordHeader.isCompressed.value) {\r\n                yield this.decompress(cursor, buffer);\r\n            }\r\n            else {\r\n                yield this.dataProvider.read(cursor, buffer);\r\n            }\r\n            return new BufferDataProvider(buffer);\r\n        });\r\n    }\r\n}\r\nclass VocHeader {\r\n    constructor(endianness) {\r\n        this.buffer = new ArrayBuffer(26);\r\n        this.identifier = new text(this.buffer, 0, 20);\r\n        this.size = new ui16(endianness, this.buffer, 20);\r\n        this.version = new ui16(endianness, this.buffer, 22);\r\n        this.validity = new ui16(endianness, this.buffer, 24);\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.buffer);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass VocSoundDataHeader {\r\n    constructor(endianness) {\r\n        this.buffer = new ArrayBuffer(2);\r\n        this.frequency = new ui08(endianness, this.buffer, 0);\r\n        this.codec = new ui08(endianness, this.buffer, 1);\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.buffer);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nvar VocCodecType;\r\n(function (VocCodecType) {\r\n    VocCodecType[VocCodecType[\"PCM_8BIT_UNSIGNED\"] = 0] = \"PCM_8BIT_UNSIGNED\";\r\n    VocCodecType[VocCodecType[\"CREATIVE_ADPCM_4BIT_8BIT\"] = 1] = \"CREATIVE_ADPCM_4BIT_8BIT\";\r\n    VocCodecType[VocCodecType[\"CREATIVE_ADPCM_3BIT_8BIT\"] = 2] = \"CREATIVE_ADPCM_3BIT_8BIT\";\r\n    VocCodecType[VocCodecType[\"CREATIVE_ADPCM_2BIT_8BIT\"] = 3] = \"CREATIVE_ADPCM_2BIT_8BIT\";\r\n    VocCodecType[VocCodecType[\"PCM_16BIT_SIGNED\"] = 4] = \"PCM_16BIT_SIGNED\";\r\n    VocCodecType[VocCodecType[\"UNKNOWN\"] = 5] = \"UNKNOWN\";\r\n    VocCodecType[VocCodecType[\"ALAW\"] = 6] = \"ALAW\";\r\n    VocCodecType[VocCodecType[\"ULAW\"] = 7] = \"ULAW\";\r\n})(VocCodecType || (VocCodecType = {}));\r\n;\r\nvar VocBlockType;\r\n(function (VocBlockType) {\r\n    VocBlockType[VocBlockType[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\r\n    VocBlockType[VocBlockType[\"SOUND_DATA\"] = 1] = \"SOUND_DATA\";\r\n    VocBlockType[VocBlockType[\"CONTINUED_SOUND_DATA\"] = 2] = \"CONTINUED_SOUND_DATA\";\r\n    VocBlockType[VocBlockType[\"SILENCE\"] = 3] = \"SILENCE\";\r\n    VocBlockType[VocBlockType[\"MARKER\"] = 4] = \"MARKER\";\r\n    VocBlockType[VocBlockType[\"TEXT\"] = 5] = \"TEXT\";\r\n    VocBlockType[VocBlockType[\"REPEAT_START\"] = 6] = \"REPEAT_START\";\r\n    VocBlockType[VocBlockType[\"REPEAT_END\"] = 7] = \"REPEAT_END\";\r\n    VocBlockType[VocBlockType[\"EXTRA_INFO\"] = 8] = \"EXTRA_INFO\";\r\n    VocBlockType[VocBlockType[\"NEW_SOUND_DATA\"] = 9] = \"NEW_SOUND_DATA\";\r\n})(VocBlockType || (VocBlockType = {}));\r\n;\r\nclass VocFile {\r\n    constructor(endianness = \"LittleEndian\") {\r\n        this.endianness = endianness;\r\n        this.header = new VocHeader(endianness);\r\n        this.blocks = new Array();\r\n    }\r\n    load(dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.blocks.splice(0, this.blocks.length);\r\n            let cursor = 0;\r\n            cursor += yield this.header.load(cursor, dataProvider);\r\n            assert.identical(this.header.identifier.value, \"Creative Voice File\\x1A\");\r\n            while (cursor < dataProvider.size()) {\r\n                let type = new ui08(this.endianness);\r\n                cursor += yield type.load(cursor, dataProvider);\r\n                if (type.value === VocBlockType.TERMINATOR) {\r\n                    this.blocks.push({\r\n                        type: type.value,\r\n                        buffer: new ArrayBuffer(0)\r\n                    });\r\n                    break;\r\n                }\r\n                else if (type.value === VocBlockType.REPEAT_END) {\r\n                    this.blocks.push({\r\n                        type: type.value,\r\n                        buffer: new ArrayBuffer(0)\r\n                    });\r\n                }\r\n                else {\r\n                    let size = new ui24(this.endianness);\r\n                    cursor += yield size.load(cursor, dataProvider);\r\n                    let buffer = new ArrayBuffer(size.value);\r\n                    cursor += yield dataProvider.read(cursor, buffer);\r\n                    this.blocks.push({\r\n                        type: type.value,\r\n                        buffer: buffer\r\n                    });\r\n                }\r\n            }\r\n            return this;\r\n        });\r\n    }\r\n    play() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.blocks.length === 0) {\r\n                return;\r\n            }\r\n            let block = this.blocks[0];\r\n            if (block.type !== VocBlockType.SOUND_DATA) {\r\n                throw `Unsupported voc block!`;\r\n            }\r\n            let dataProvider = new BufferDataProvider(block.buffer);\r\n            let cursor = 0;\r\n            let header = new VocSoundDataHeader(this.endianness);\r\n            cursor += yield header.load(cursor, dataProvider);\r\n            if (![VocCodecType.PCM_8BIT_UNSIGNED, VocCodecType.PCM_16BIT_SIGNED].includes(header.codec.value)) {\r\n                throw `Unsupported voc codec!`;\r\n            }\r\n            let channels = 1;\r\n            let bytesPerChannel = header.codec.value === VocCodecType.PCM_8BIT_UNSIGNED ? 1 : 2;\r\n            let bytesPerFrame = bytesPerChannel * channels;\r\n            let samples = (dataProvider.size() - cursor) / bytesPerFrame;\r\n            let sampleRate = Math.floor(1000000 / (256 - header.frequency.value));\r\n            let context = new AudioContext();\r\n            let buffer = context.createBuffer(channels, samples, sampleRate);\r\n            if (bytesPerChannel === 1) {\r\n                let sample = new ui08(this.endianness);\r\n                for (let s = 0; s < samples; s++) {\r\n                    for (let c = 0; c < channels; c++) {\r\n                        cursor += yield sample.load(cursor, dataProvider);\r\n                        let value = ((sample.value + 0) / 255) * 2.0 - 1.0;\r\n                        buffer.getChannelData(c)[s] = value;\r\n                    }\r\n                }\r\n            }\r\n            else if (bytesPerChannel === 2) {\r\n                let sample = new si16(this.endianness);\r\n                for (let s = 0; s < samples; s++) {\r\n                    for (let c = 0; c < channels; c++) {\r\n                        cursor += yield sample.load(cursor, dataProvider);\r\n                        let value = ((sample.value + 32768) / 65535) * 2.0 - 1.0;\r\n                        buffer.getChannelData(c)[s] = value;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw `Expected 8 or 16 bits per sample!`;\r\n            }\r\n            let source = context.createBufferSource();\r\n            source.buffer = buffer;\r\n            source.connect(context.destination);\r\n            source.start();\r\n        });\r\n    }\r\n}\r\nclass RiffChunkHeader {\r\n    constructor(endianness) {\r\n        this.buffer = new ArrayBuffer(8);\r\n        this.id = new text(this.buffer, 0, 4);\r\n        this.size = new ui32(endianness, this.buffer, 4);\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.buffer);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass WavHeader {\r\n    constructor(endianness) {\r\n        this.buffer = new ArrayBuffer(16);\r\n        this.audioFormat = new ui16(endianness, this.buffer, 0);\r\n        this.numChannels = new ui16(endianness, this.buffer, 2);\r\n        this.sampleRate = new ui32(endianness, this.buffer, 4);\r\n        this.byteRate = new ui32(endianness, this.buffer, 8);\r\n        this.blockAlign = new ui16(endianness, this.buffer, 12);\r\n        this.bitsPerSample = new ui16(endianness, this.buffer, 14);\r\n    }\r\n    load(cursor, dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let length = 0;\r\n            length += yield dataProvider.read(cursor + length, this.buffer);\r\n            return length;\r\n        });\r\n    }\r\n}\r\nclass WavFile {\r\n    constructor(endianness = \"LittleEndian\") {\r\n        this.endianness = endianness;\r\n        this.header = new WavHeader(endianness);\r\n        this.buffer = new ArrayBuffer(0);\r\n    }\r\n    load(dataProvider) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let cursor = 0;\r\n            let chunk = new RiffChunkHeader(this.endianness);\r\n            cursor += yield chunk.load(cursor, dataProvider);\r\n            assert.identical(chunk.id.value, \"RIFF\");\r\n            let buffer = new ArrayBuffer(chunk.size.value);\r\n            yield dataProvider.read(cursor, buffer);\r\n            {\r\n                let dataProvider = new BufferDataProvider(buffer);\r\n                let cursor = 0;\r\n                let id = new text(new ArrayBuffer(4));\r\n                cursor += yield id.load(cursor, dataProvider);\r\n                assert.identical(id.value, \"WAVE\");\r\n                let format = new RiffChunkHeader(this.endianness);\r\n                cursor += yield format.load(cursor, dataProvider);\r\n                assert.identical(format.id.value, \"fmt \");\r\n                cursor += yield this.header.load(cursor, dataProvider);\r\n                cursor += format.size.value % 2;\r\n                let data = new RiffChunkHeader(this.endianness);\r\n                cursor += yield data.load(cursor, dataProvider);\r\n                assert.identical(data.id.value, \"data\");\r\n                this.buffer = new ArrayBuffer(data.size.value);\r\n                length += yield dataProvider.read(cursor, this.buffer);\r\n                cursor += format.size.value % 2;\r\n            }\r\n            return this;\r\n        });\r\n    }\r\n    play() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let channels = this.header.numChannels.value;\r\n            let samples = this.buffer.byteLength / this.header.blockAlign.value;\r\n            let sampleRate = this.header.sampleRate.value;\r\n            let context = new AudioContext();\r\n            let buffer = context.createBuffer(channels, samples, sampleRate);\r\n            let dataProvider = new BufferDataProvider(this.buffer);\r\n            let cursor = 0;\r\n            if (this.header.bitsPerSample.value === 8) {\r\n                let sample = new ui08(this.endianness);\r\n                for (let s = 0; s < samples; s++) {\r\n                    for (let c = 0; c < channels; c++) {\r\n                        cursor += yield sample.load(cursor, dataProvider);\r\n                        let value = ((sample.value + 0) / 255) * 2.0 - 1.0;\r\n                        buffer.getChannelData(c)[s] = value;\r\n                    }\r\n                }\r\n            }\r\n            else if (this.header.bitsPerSample.value === 16) {\r\n                let sample = new si16(this.endianness);\r\n                for (let s = 0; s < samples; s++) {\r\n                    for (let c = 0; c < channels; c++) {\r\n                        cursor += yield sample.load(cursor, dataProvider);\r\n                        let value = ((sample.value + 32768) / 65535) * 2.0 - 1.0;\r\n                        buffer.getChannelData(c)[s] = value;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw `Expected 8 or 16 bits per sample!`;\r\n            }\r\n            let source = context.createBufferSource();\r\n            source.buffer = buffer;\r\n            source.connect(context.destination);\r\n            source.start();\r\n        });\r\n    }\r\n}\r\nvar wc1;\r\n(function (wc1) {\r\n    class MicrotileHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(2);\r\n            let integer = new ui16(endianness, this.buffer);\r\n            this.inverted = new pi16(integer, 0, 1);\r\n            this.mirrored = new pi16(integer, 1, 1);\r\n            this.index = new pi16(integer, 5, 11);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.MicrotileHeader = MicrotileHeader;\r\n    ;\r\n    class TileHeader {\r\n        constructor(endianness) {\r\n            let a = new MicrotileHeader(endianness);\r\n            let b = new MicrotileHeader(endianness);\r\n            let c = new MicrotileHeader(endianness);\r\n            let d = new MicrotileHeader(endianness);\r\n            this.layout = [\r\n                [a, b],\r\n                [c, d]\r\n            ];\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                for (let y = 0; y < this.layout.length; y++) {\r\n                    for (let x = 0; x < this.layout[y].length; x++) {\r\n                        length += yield this.layout[y][x].load(cursor + length, dataProvider);\r\n                    }\r\n                }\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.TileHeader = TileHeader;\r\n    ;\r\n    class UnitScriptHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(12);\r\n            this.spawnOffset = new ui16(endianness, this.buffer, 0);\r\n            this.deathOffset = new ui16(endianness, this.buffer, 2);\r\n            this.idleOffset = new ui16(endianness, this.buffer, 4);\r\n            this.movementOffset = new ui16(endianness, this.buffer, 6);\r\n            this.actionOffset = new ui16(endianness, this.buffer, 8);\r\n            this.trainOffset = new ui16(endianness, this.buffer, 10);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.UnitScriptHeader = UnitScriptHeader;\r\n    ;\r\n    class ParticleScriptHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(6);\r\n            this.spawnOffset = new ui16(endianness, this.buffer, 0);\r\n            this.movementOffset = new ui16(endianness, this.buffer, 2);\r\n            this.hitOffset = new ui16(endianness, this.buffer, 4);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.ParticleScriptHeader = ParticleScriptHeader;\r\n    ;\r\n    class ScriptHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(6);\r\n            this.headerOffset = new ui16(endianness, this.buffer, 0);\r\n            this.unitScriptCount = new ui16(endianness, this.buffer, 2);\r\n            this.particleScriptCount = new ui16(endianness, this.buffer, 4);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.ScriptHeader = ScriptHeader;\r\n    ;\r\n    class Script {\r\n        constructor(endianness) {\r\n            this.endianness = endianness;\r\n            this.header = new ScriptHeader(endianness);\r\n            this.unitScriptHeaders = new Array();\r\n            this.particleScriptHeaders = new Array();\r\n            this.buffer = new ArrayBuffer(0);\r\n        }\r\n        load(dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                this.unitScriptHeaders.splice(0, this.unitScriptHeaders.length);\r\n                this.particleScriptHeaders.splice(0, this.particleScriptHeaders.length);\r\n                let cursor = 0;\r\n                let offsets = new Array();\r\n                let offset = new ui16(this.endianness);\r\n                while (true) {\r\n                    cursor += yield offset.load(cursor, dataProvider);\r\n                    if (cursor - 2 === offset.value) {\r\n                        cursor -= 2;\r\n                        break;\r\n                    }\r\n                    offsets.push(offset.value);\r\n                }\r\n                cursor += yield this.header.load(cursor, dataProvider);\r\n                for (let i = 0; i < this.header.unitScriptCount.value; i++) {\r\n                    let offset = offsets[i];\r\n                    let unitScriptHeader = new UnitScriptHeader(this.endianness);\r\n                    yield unitScriptHeader.load(offset, dataProvider);\r\n                    this.unitScriptHeaders.push(unitScriptHeader);\r\n                }\r\n                for (let i = 0; i < this.header.particleScriptCount.value; i++) {\r\n                    let offset = offsets[this.header.unitScriptCount.value + i];\r\n                    let particleScriptHeader = new ParticleScriptHeader(this.endianness);\r\n                    yield particleScriptHeader.load(offset, dataProvider);\r\n                    this.particleScriptHeaders.push(particleScriptHeader);\r\n                }\r\n                this.buffer = new ArrayBuffer(dataProvider.size());\r\n                yield dataProvider.read(0, this.buffer);\r\n                return this;\r\n            });\r\n        }\r\n        getUnitScript(index) {\r\n            assert.between(0, index, this.unitScriptHeaders.length - 1);\r\n            let header = this.unitScriptHeaders[index];\r\n            let buffer = this.buffer;\r\n            return {\r\n                header,\r\n                buffer\r\n            };\r\n        }\r\n        getParticle(index) {\r\n            assert.between(0, index, this.particleScriptHeaders.length - 1);\r\n            let header = this.particleScriptHeaders[index];\r\n            let buffer = this.buffer;\r\n            return {\r\n                header,\r\n                buffer\r\n            };\r\n        }\r\n    }\r\n    wc1.Script = Script;\r\n    class SpriteFrameHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(8);\r\n            this.x = new ui08(endianness, this.buffer, 0);\r\n            this.y = new ui08(endianness, this.buffer, 1);\r\n            this.w = new ui08(endianness, this.buffer, 2);\r\n            this.h = new ui08(endianness, this.buffer, 3);\r\n            this.offset = new ui32(endianness, this.buffer, 4);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.SpriteFrameHeader = SpriteFrameHeader;\r\n    ;\r\n    class SpriteFrame {\r\n        constructor(endianness) {\r\n            this.header = new SpriteFrameHeader(endianness);\r\n            this.buffer = new ArrayBuffer(0);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield this.header.load(cursor + length, dataProvider);\r\n                this.buffer = new ArrayBuffer(this.header.w.value * this.header.h.value);\r\n                yield dataProvider.read(this.header.offset.value, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n        makeTexture(context, width, height) {\r\n            let x = this.header.x.value;\r\n            let y = this.header.y.value;\r\n            let w = this.header.w.value;\r\n            let h = this.header.h.value;\r\n            let texture = context.createTexture();\r\n            if (is.absent(texture)) {\r\n                throw `Expected a texture!`;\r\n            }\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, texture);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\r\n            context.texImage2D(context.TEXTURE_2D, 0, context.LUMINANCE, width, height, 0, context.LUMINANCE, context.UNSIGNED_BYTE, null);\r\n            context.texSubImage2D(context.TEXTURE_2D, 0, x, y, w, h, context.LUMINANCE, context.UNSIGNED_BYTE, new Uint8Array(this.buffer));\r\n            return texture;\r\n        }\r\n    }\r\n    wc1.SpriteFrame = SpriteFrame;\r\n    ;\r\n    class SpriteHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(4);\r\n            this.spriteCount = new ui16(endianness, this.buffer, 0);\r\n            this.w = new ui08(endianness, this.buffer, 2);\r\n            this.h = new ui08(endianness, this.buffer, 3);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.SpriteHeader = SpriteHeader;\r\n    ;\r\n    class Sprite {\r\n        constructor(endianness) {\r\n            this.endianness = endianness;\r\n            this.header = new SpriteHeader(endianness);\r\n            this.frames = new Array();\r\n        }\r\n        load(dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                this.frames.splice(0, this.frames.length);\r\n                let cursor = 0;\r\n                cursor += yield this.header.load(cursor, dataProvider);\r\n                for (let i = 0; i < this.header.spriteCount.value; i++) {\r\n                    let frame = new SpriteFrame(this.endianness);\r\n                    cursor += yield frame.load(cursor, dataProvider);\r\n                    this.frames.push(frame);\r\n                }\r\n                return this;\r\n            });\r\n        }\r\n        makeTextures(context) {\r\n            let w = this.header.w.value;\r\n            let h = this.header.h.value;\r\n            let textures = new Array();\r\n            for (let frame of this.frames) {\r\n                let texture = frame.makeTexture(context, w, h);\r\n                textures.push(texture);\r\n            }\r\n            return textures;\r\n        }\r\n    }\r\n    wc1.Sprite = Sprite;\r\n    ;\r\n    class Map {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(0);\r\n        }\r\n        load(dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let cursor = 0;\r\n                this.buffer = new ArrayBuffer(64 * 64 * 2);\r\n                cursor += yield dataProvider.read(cursor, this.buffer);\r\n                return this;\r\n            });\r\n        }\r\n    }\r\n    wc1.Map = Map;\r\n    ;\r\n    class CursorHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(8);\r\n            this.x = new ui16(endianness, this.buffer, 0);\r\n            this.y = new ui16(endianness, this.buffer, 2);\r\n            this.w = new ui16(endianness, this.buffer, 4);\r\n            this.h = new ui16(endianness, this.buffer, 6);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.CursorHeader = CursorHeader;\r\n    ;\r\n    class Cursor {\r\n        constructor(endianness) {\r\n            this.header = new CursorHeader(endianness);\r\n            this.buffer = new ArrayBuffer(0);\r\n        }\r\n        load(dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let cursor = 0;\r\n                cursor += yield this.header.load(cursor, dataProvider);\r\n                this.buffer = new ArrayBuffer(this.header.w.value * this.header.h.value);\r\n                cursor += yield dataProvider.read(cursor, this.buffer);\r\n                return this;\r\n            });\r\n        }\r\n        makeTexture(context) {\r\n            let w = this.header.w.value;\r\n            let h = this.header.h.value;\r\n            let texture = context.createTexture();\r\n            if (is.absent(texture)) {\r\n                throw `Expected a texture!`;\r\n            }\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, texture);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\r\n            context.texImage2D(context.TEXTURE_2D, 0, context.LUMINANCE, w, h, 0, context.LUMINANCE, context.UNSIGNED_BYTE, null);\r\n            context.texSubImage2D(context.TEXTURE_2D, 0, 0, 0, w, h, context.LUMINANCE, context.UNSIGNED_BYTE, new Uint8Array(this.buffer));\r\n            return texture;\r\n        }\r\n    }\r\n    wc1.Cursor = Cursor;\r\n    ;\r\n    class Palette {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(0);\r\n        }\r\n        load(dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                assert.between(0, dataProvider.size() % 3, 0);\r\n                let cursor = 0;\r\n                this.buffer = new ArrayBuffer(dataProvider.size());\r\n                cursor += yield dataProvider.read(cursor, this.buffer);\r\n                return this;\r\n            });\r\n        }\r\n        makeTexture(context) {\r\n            let w = this.buffer.byteLength / 3;\r\n            let h = 1;\r\n            let texture = context.createTexture();\r\n            if (is.absent(texture)) {\r\n                throw `Expected a texture!`;\r\n            }\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, texture);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\r\n            context.texImage2D(context.TEXTURE_2D, 0, context.RGB, 256, 1, 0, context.RGB, context.UNSIGNED_BYTE, null);\r\n            context.texSubImage2D(context.TEXTURE_2D, 0, 0, 0, w, h, context.RGB, context.UNSIGNED_BYTE, new Uint8Array(this.buffer));\r\n            return texture;\r\n        }\r\n        updateTexture(texture, start) {\r\n            let w = this.buffer.byteLength / 3;\r\n            let h = 1;\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, texture);\r\n            context.texSubImage2D(context.TEXTURE_2D, 0, start, 0, w, h, context.RGB, context.UNSIGNED_BYTE, new Uint8Array(this.buffer));\r\n            return this;\r\n        }\r\n    }\r\n    wc1.Palette = Palette;\r\n    ;\r\n    class BitmapHeader {\r\n        constructor(endianness) {\r\n            this.buffer = new ArrayBuffer(4);\r\n            this.w = new ui16(endianness, this.buffer, 0);\r\n            this.h = new ui16(endianness, this.buffer, 2);\r\n        }\r\n        load(cursor, dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let length = 0;\r\n                length += yield dataProvider.read(cursor + length, this.buffer);\r\n                return length;\r\n            });\r\n        }\r\n    }\r\n    wc1.BitmapHeader = BitmapHeader;\r\n    ;\r\n    class Bitmap {\r\n        constructor(endianness) {\r\n            this.header = new BitmapHeader(endianness);\r\n            this.buffer = new ArrayBuffer(0);\r\n        }\r\n        load(dataProvider) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                let cursor = 0;\r\n                cursor += yield this.header.load(cursor, dataProvider);\r\n                this.buffer = new ArrayBuffer(this.header.w.value * this.header.h.value);\r\n                cursor += yield dataProvider.read(cursor, this.buffer);\r\n                return this;\r\n            });\r\n        }\r\n        makeTexture(context) {\r\n            let w = this.header.w.value;\r\n            let h = this.header.h.value;\r\n            let texture = context.createTexture();\r\n            if (is.absent(texture)) {\r\n                throw `Expected a texture!`;\r\n            }\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, texture);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\r\n            context.texImage2D(context.TEXTURE_2D, 0, context.LUMINANCE, w, h, 0, context.LUMINANCE, context.UNSIGNED_BYTE, null);\r\n            context.texSubImage2D(context.TEXTURE_2D, 0, 0, 0, w, h, context.LUMINANCE, context.UNSIGNED_BYTE, new Uint8Array(this.buffer));\r\n            return texture;\r\n        }\r\n    }\r\n    wc1.Bitmap = Bitmap;\r\n    ;\r\n})(wc1 || (wc1 = {}));\r\nlet canvas = document.createElement(\"canvas\");\r\nlet context = canvas.getContext(\"webgl2\");\r\nif (is.absent(context)) {\r\n    throw `Expected a context!`;\r\n}\r\ncontext.clearColor(0.0, 0.0, 0.0, 1.0);\r\ncontext.pixelStorei(context.UNPACK_ALIGNMENT, 1);\r\nlet program = context.createProgram();\r\nif (is.absent(program)) {\r\n    throw `Expected a program!`;\r\n}\r\nlet vertexShader = context.createShader(context.VERTEX_SHADER);\r\nif (is.absent(vertexShader)) {\r\n    throw `Expected a shader!`;\r\n}\r\ncontext.shaderSource(vertexShader, `#version 300 es\r\n\tuniform ivec2 viewport;\r\n\tuniform bvec2 scaling;\r\n\tuniform vec2 anchor;\r\n\tuniform vec2 quad;\r\n\tuniform sampler2D paletteSampler;\r\n\tuniform sampler2D textureSampler;\r\n\tin vec2 vertexPosition;\r\n\tin vec2 vertexTexture;\r\n\tout vec2 textureCoordinates;\r\n\tvoid main() {\r\n\t\tfloat zoom = 4.0;\r\n\t\ttextureCoordinates = vertexTexture;\r\n\t\tif (scaling.x) {\r\n\t\t\ttextureCoordinates.x = 1.0 - textureCoordinates.x;\r\n\t\t}\r\n\t\tif (scaling.y) {\r\n\t\t\ttextureCoordinates.y = 1.0 - textureCoordinates.y;\r\n\t\t}\r\n\t\tivec2 texSize = textureSize(textureSampler, 0);\r\n\t\tvec2 vvpos = vec2(quad) + (vertexPosition - anchor) * vec2(texSize);\r\n\t\tmat3x3 transform = mat3x3(vec3(2.0 / float(viewport.x), 0.0, 0.0), vec3(0.0, -2.0 / float(viewport.y), 0.0), vec3(-1.0, 1.0, 1.0));\r\n\t\tgl_Position = vec4((transform * vec3(vvpos * zoom, 1.0)).xy, 0.0, 1.0);\r\n\t}\r\n`);\r\ncontext.compileShader(vertexShader);\r\nif (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {\r\n    let info = context.getShaderInfoLog(vertexShader);\r\n    throw `${info}`;\r\n}\r\nlet fragmentShader = context.createShader(context.FRAGMENT_SHADER);\r\nif (is.absent(fragmentShader)) {\r\n    throw `Expected a shader!`;\r\n}\r\ncontext.shaderSource(fragmentShader, `#version 300 es\r\n\tprecision highp float;\r\n\tuniform int transparentIndex;\r\n\tuniform sampler2D colorCycleSampler;\r\n\tuniform sampler2D paletteSampler;\r\n\tuniform sampler2D textureSampler;\r\n\tin vec2 textureCoordinates;\r\n\tout vec4 fragmentColor;\r\n\tvoid main() {\r\n\t\tfloat index = texture(textureSampler, textureCoordinates).x;\r\n\t\tint indexInt = int(index * float(textureSize(textureSampler, 0).x));\r\n\t\tif (indexInt == transparentIndex) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t\tfloat shiftedIndex = texture(colorCycleSampler, vec2(index, 0.0)).x;\r\n\t\tvec3 color = texture(paletteSampler, vec2(shiftedIndex, 0.0)).rgb * 4.0;\r\n\t\tfragmentColor = vec4(color, 1.0);\r\n\t}\r\n`);\r\ncontext.compileShader(fragmentShader);\r\nif (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {\r\n    let info = context.getShaderInfoLog(fragmentShader);\r\n    throw `${info}`;\r\n}\r\ncontext.attachShader(program, vertexShader);\r\ncontext.attachShader(program, fragmentShader);\r\ncontext.linkProgram(program);\r\nif (!context.getProgramParameter(program, context.LINK_STATUS)) {\r\n    let info = context.getProgramInfoLog(program);\r\n    throw `${info}`;\r\n}\r\ncontext.useProgram(program);\r\nlet viewportLocation = context.getUniformLocation(program, \"viewport\");\r\nlet quadLocation = context.getUniformLocation(program, \"quad\");\r\nlet scalingLocation = context.getUniformLocation(program, \"scaling\");\r\nlet anchorLocation = context.getUniformLocation(program, \"anchor\");\r\nlet transparentIndexLocation = context.getUniformLocation(program, \"transparentIndex\");\r\ncontext.uniform1i(transparentIndexLocation, 0);\r\nlet textureSamplerocation = context.getUniformLocation(program, \"textureSampler\");\r\ncontext.uniform1i(textureSamplerocation, 0);\r\nlet paletteSamplerLocation = context.getUniformLocation(program, \"paletteSampler\");\r\ncontext.uniform1i(paletteSamplerLocation, 1);\r\nlet colorCycleSamplerLocation = context.getUniformLocation(program, \"colorCycleSampler\");\r\ncontext.uniform1i(colorCycleSamplerLocation, 2);\r\nlet vertexPosition = context.getAttribLocation(program, \"vertexPosition\");\r\ncontext.enableVertexAttribArray(vertexPosition);\r\nlet vertexTexture = context.getAttribLocation(program, \"vertexTexture\");\r\ncontext.enableVertexAttribArray(vertexTexture);\r\nlet buffer = context.createBuffer();\r\nif (is.absent(buffer)) {\r\n    throw `Expected a buffer!`;\r\n}\r\ncontext.bindBuffer(context.ARRAY_BUFFER, buffer);\r\ncontext.bufferData(context.ARRAY_BUFFER, new Float32Array([\r\n    0.0, 0.0, 0.0, 0.0,\r\n    0.0, 1.0, 0.0, 1.0,\r\n    1.0, 1.0, 1.0, 1.0,\r\n    0.0, 0.0, 0.0, 0.0,\r\n    1.0, 1.0, 1.0, 1.0,\r\n    1.0, 0.0, 1.0, 0.0\r\n]), context.STATIC_DRAW);\r\ncontext.vertexAttribPointer(vertexPosition, 2, context.FLOAT, false, 16, 0);\r\ncontext.vertexAttribPointer(vertexTexture, 2, context.FLOAT, false, 16, 8);\r\ncanvas.setAttribute(\"style\", \"height: 100%; width: 100%;\");\r\ncanvas.addEventListener(\"dragenter\", (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n    event.stopPropagation();\r\n    event.preventDefault();\r\n}));\r\ncanvas.addEventListener(\"dragover\", (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n    event.stopPropagation();\r\n    event.preventDefault();\r\n}));\r\nlet endianness = \"LittleEndian\";\r\nlet archive;\r\nfunction load(dataProvider) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        archive = new Archive(dataProvider, endianness);\r\n        tileset = yield loadTileset(context, archive, endianness, 189, 190, 191);\r\n        //tileset = await loadTileset(context, archive, endianness, 192, 193, 194);\r\n        //tileset = await loadTileset(context, archive, endianness, 195, 196, 197);\r\n        map = yield loadMap(archive, endianness, 63);\r\n        try {\r\n            yield loadUnitScript(archive);\r\n        }\r\n        catch (error) {\r\n            try {\r\n                yield loadParticleScript(archive);\r\n            }\r\n            catch (error) { }\r\n        }\r\n        /* \t\t\tlet voc = await new VocFile().load(await archive.getRecord(503));\r\n            await voc.play(); */\r\n        /* \t\t\tlet wave = await new WavFile().load(await archive.getRecord(504));\r\n            await wave.play(); */\r\n    });\r\n}\r\nfunction loadTileset(context, archive, endianness, tilesetIndex, tilesIndex, paletteIndex) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let base_palette = yield new wc1.Palette(endianness).load(yield archive.getRecord(paletteIndex));\r\n        let paletteTexture = yield base_palette.makeTexture(context);\r\n        let palette = yield new wc1.Palette(endianness).load(yield archive.getRecord(210));\r\n        palette.updateTexture(paletteTexture, 128);\r\n        context.activeTexture(context.TEXTURE1);\r\n        context.bindTexture(context.TEXTURE_2D, paletteTexture);\r\n        let tiles = yield archive.getRecord(tilesIndex);\r\n        assert.assert((tiles.size() % (8 * 8)) === 0);\r\n        let headers = yield archive.getRecord(tilesetIndex);\r\n        let cursor = 0;\r\n        assert.assert((tiles.size() % 8) === 0);\r\n        let textures = new Array();\r\n        let array = new Uint8Array(8 * 8);\r\n        while (cursor < headers.size()) {\r\n            let w = 2 * 8;\r\n            let h = 2 * 8;\r\n            let texture = context.createTexture();\r\n            if (is.absent(texture)) {\r\n                throw `Expected a texture!`;\r\n            }\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, texture);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\r\n            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\r\n            context.texImage2D(context.TEXTURE_2D, 0, context.LUMINANCE, w, h, 0, context.LUMINANCE, context.UNSIGNED_BYTE, null);\r\n            let tileHeader = new wc1.TileHeader(endianness);\r\n            cursor += yield tileHeader.load(cursor, headers);\r\n            for (let y = 0; y < tileHeader.layout.length; y++) {\r\n                for (let x = 0; x < tileHeader.layout[y].length; x++) {\r\n                    let header = tileHeader.layout[y][x];\r\n                    yield tiles.read(header.index.value * 8 * 8, array.buffer);\r\n                    if (header.inverted.value) {\r\n                        for (let y = 0; y < 8 / 2; y++) {\r\n                            for (let x = 0; x < 8; x++) {\r\n                                let indexOne = (y * 8) + x;\r\n                                let indexTwo = ((8 - y - 1) * 8) + x;\r\n                                let valueOne = array[indexOne];\r\n                                let valueTwo = array[indexTwo];\r\n                                array[indexOne] = valueTwo;\r\n                                array[indexTwo] = valueOne;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (header.mirrored.value) {\r\n                        for (let y = 0; y < 8; y++) {\r\n                            for (let x = 0; x < 8 / 2; x++) {\r\n                                let indexOne = (y * 8) + x;\r\n                                let indexTwo = (y * 8) + 8 - x - 1;\r\n                                let valueOne = array[indexOne];\r\n                                let valueTwo = array[indexTwo];\r\n                                array[indexOne] = valueTwo;\r\n                                array[indexTwo] = valueOne;\r\n                            }\r\n                        }\r\n                    }\r\n                    context.texSubImage2D(context.TEXTURE_2D, 0, x * 8, y * 8, 8, 8, context.LUMINANCE, context.UNSIGNED_BYTE, array);\r\n                }\r\n            }\r\n            textures.push(texture);\r\n        }\r\n        return textures;\r\n    });\r\n}\r\nfunction loadMap(archive, endianness, mapIndex) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let indices = new Array();\r\n        let integer = new ui16(endianness);\r\n        let dataProider = yield archive.getRecord(mapIndex);\r\n        assert.assert(dataProider.size() === 64 * 64 * 2);\r\n        let cursor = 0;\r\n        for (let y = 0; y < 64; y++) {\r\n            for (let x = 0; x < 64; x++) {\r\n                cursor += yield integer.load(cursor, dataProider);\r\n                indices.push(integer.value);\r\n            }\r\n        }\r\n        return indices;\r\n    });\r\n}\r\nlet entities = [\r\n    { name: \"Footman\", script: 0, sprite: 279, sfx: [487, 488, 489] },\r\n    { name: \"Grunt\", script: 1, sprite: 280, sfx: [487, 488, 489] },\r\n    { name: \"Peasant\", script: 2, sprite: 281, sfx: [477, 478, 479] },\r\n    { name: \"Peon\", script: 3, sprite: 282, sfx: [477, 478, 479] },\r\n    { name: \"Catapult\", script: 4, sprite: 283, sfx: [476] },\r\n    { name: \"Catapult\", script: 5, sprite: 284, sfx: [476] },\r\n    { name: \"Knight\", script: 6, sprite: 285, sfx: [487, 488, 489] },\r\n    { name: \"Raider\", script: 7, sprite: 286, sfx: [487, 488, 489] },\r\n    { name: \"Archer\", script: 8, sprite: 287, sfx: [493] },\r\n    { name: \"Spearman\", script: 9, sprite: 288, sfx: [493] },\r\n    { name: \"Conjurer\", script: 10, sprite: 289, sfx: [] },\r\n    { name: \"Warlock\", script: 11, sprite: 290, sfx: [] },\r\n    { name: \"Cleric\", script: 12, sprite: 291, sfx: [] },\r\n    { name: \"Necrolyte\", script: 13, sprite: 292, sfx: [] },\r\n    { name: \"Medivh\", script: 14, sprite: 293, sfx: [] },\r\n    { name: \"Sir Lothar\", script: 15, sprite: 294, sfx: [] },\r\n    { name: \"Grunt (copy)\", script: 16, sprite: 280, sfx: [] },\r\n    { name: \"Griselda\", script: 17, sprite: 296, sfx: [] },\r\n    { name: \"Garona\", script: 18, sprite: 296, sfx: [] },\r\n    { name: \"Ogre\", script: 19, sprite: 297, sfx: [] },\r\n    { name: \"Ogre (copy)\", script: 20, sprite: 297, sfx: [] },\r\n    { name: \"Spider\", script: 21, sprite: 298, sfx: [] },\r\n    { name: \"Slime\", script: 22, sprite: 299, sfx: [] },\r\n    { name: \"Fire Elemental\", script: 23, sprite: 300, sfx: [] },\r\n    { name: \"Scorpion\", script: 24, sprite: 301, sfx: [] },\r\n    { name: \"Brigand\", script: 25, sprite: 302, sfx: [] },\r\n    { name: \"Skeleton\", script: 26, sprite: 303, sfx: [] },\r\n    { name: \"Skeleton\", script: 27, sprite: 304, sfx: [] },\r\n    { name: \"Daemon\", script: 28, sprite: 305, sfx: [] },\r\n    { name: \"Ogre (copy 2)\", script: 29, sprite: 297, sfx: [] },\r\n    { name: \"Ogre (copy 3)\", script: 30, sprite: 297, sfx: [] },\r\n    { name: \"Water Elemental\", script: 31, sprite: 306, sfx: [] },\r\n    { name: \"Farm\", script: 32, sprite: 307, sfx: [] },\r\n    { name: \"Farm\", script: 33, sprite: 308, sfx: [] },\r\n    { name: \"Barracks\", script: 34, sprite: 309, sfx: [] },\r\n    { name: \"Barracks\", script: 35, sprite: 310, sfx: [] },\r\n    { name: \"Church\", script: 36, sprite: 311, sfx: [] },\r\n    { name: \"Temple\", script: 37, sprite: 312, sfx: [] },\r\n    { name: \"Tower\", script: 38, sprite: 313, sfx: [] },\r\n    { name: \"Tower\", script: 39, sprite: 314, sfx: [] },\r\n    { name: \"Town Hall\", script: 40, sprite: 315, sfx: [] },\r\n    { name: \"Town Hall\", script: 41, sprite: 316, sfx: [] },\r\n    { name: \"Mill\", script: 42, sprite: 317, sfx: [] },\r\n    { name: \"Mill\", script: 43, sprite: 318, sfx: [] },\r\n    { name: \"Stables\", script: 44, sprite: 319, sfx: [] },\r\n    { name: \"Kennel\", script: 45, sprite: 320, sfx: [] },\r\n    { name: \"Blacksmith\", script: 46, sprite: 321, sfx: [] },\r\n    { name: \"Blacksmith\", script: 47, sprite: 322, sfx: [] },\r\n    { name: \"Stormwind Keep\", script: 48, sprite: 323, sfx: [] },\r\n    { name: \"Black Rock Spire\", script: 49, sprite: 324, sfx: [] },\r\n    { name: \"Gold Mine\", script: 50, sprite: 325, sfx: [] },\r\n    { name: \"Blob\", script: 0, type: \"effect\", sprite: 347, sfx: [] },\r\n    { name: \"Fire Ball\", script: 1, type: \"effect\", sprite: 348, sfx: [] },\r\n    { name: \"Spear\", script: 2, type: \"effect\", sprite: 349, sfx: [] },\r\n    { name: \"Poison Cloud\", script: 3, type: \"effect\", sprite: 350, sfx: [] },\r\n    { name: \"Catapult Projectile\", script: 4, type: \"effect\", sprite: 351, sfx: [] },\r\n    { name: \"Burning Small\", script: 5, type: \"effect\", sprite: 352, sfx: [] },\r\n    { name: \"Burning Medium\", script: 6, type: \"effect\", sprite: 353, sfx: [] },\r\n    { name: \"Explosion\", script: 7, type: \"effect\", sprite: 354, sfx: [] },\r\n    { name: \"Sparkle\", script: 8, type: \"effect\", sprite: 355, sfx: [] },\r\n    { name: \"Building Collapse\", script: 9, type: \"effect\", sprite: 356, sfx: [] },\r\n    { name: \"Water Elemental\", script: 10, type: \"effect\", sprite: 357, sfx: [] },\r\n    { name: \"Fire Elemental\", script: 11, type: \"effect\", sprite: 358, sfx: [] },\r\n];\r\nlet w = 256;\r\nlet h = 1;\r\nlet colorCycleTexture = context.createTexture();\r\nlet colorCycleBuffer = new Uint8Array(w * h);\r\nfor (let i = 0; i < 256; i++) {\r\n    colorCycleBuffer[i] = i;\r\n}\r\nif (is.absent(colorCycleTexture)) {\r\n    throw `Expected a texture!`;\r\n}\r\ncontext.activeTexture(context.TEXTURE2);\r\ncontext.bindTexture(context.TEXTURE_2D, colorCycleTexture);\r\ncontext.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);\r\ncontext.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);\r\ncontext.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);\r\ncontext.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);\r\ncontext.texImage2D(context.TEXTURE_2D, 0, context.LUMINANCE, 256, 1, 0, context.LUMINANCE, context.UNSIGNED_BYTE, colorCycleBuffer);\r\nlet cycleWait = 0;\r\nfunction updateCycle() {\r\n    if (cycleWait > 0) {\r\n        cycleWait -= 1;\r\n        return;\r\n    }\r\n    cycleWait = 6;\r\n    let first = colorCycleBuffer[112];\r\n    for (let i = 112; i < 112 + 8 - 1; i++) {\r\n        colorCycleBuffer[i] = colorCycleBuffer[i + 1];\r\n    }\r\n    colorCycleBuffer[112 + 8 - 1] = first;\r\n    context.activeTexture(context.TEXTURE2);\r\n    context.bindTexture(context.TEXTURE_2D, colorCycleTexture);\r\n    context.texSubImage2D(context.TEXTURE_2D, 0, 112, 0, 8, 1, context.LUMINANCE, context.UNSIGNED_BYTE, colorCycleBuffer, 112);\r\n}\r\nlet textures = new Array();\r\nlet entity = 0;\r\nlet offset;\r\nlet delay = 0;\r\nlet direction = 0;\r\nlet frame = 0;\r\nlet view;\r\nlet sfx = [];\r\nfunction loadUnitScript(archive) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let entitydata = entities[entity];\r\n        let sprite = yield new wc1.Sprite(endianness).load(yield archive.getRecord(entitydata.sprite));\r\n        textures = yield sprite.makeTextures(context);\r\n        let script = yield new wc1.Script(endianness).load(yield archive.getRecord(212));\r\n        let us = script.getUnitScript(entitydata.script);\r\n        console.log(JSON.stringify(Object.assign(Object.assign({}, entitydata), { armor: shared.armor[entity], armorPiercingDamage: shared.armorPiercingDamage[entity], damage: shared.damage[entity], goldCost: shared.goldCost[entity] * 10, health: shared.health[entity], timeCost: shared.timeCost[entity] * 10, range: shared.range[entity], woodCost: shared.woodCost[entity] * 10 }), null, \"\\t\"));\r\n        view = new DataView(us.buffer);\r\n        frame = 0;\r\n        offset = us.header.movementOffset.value;\r\n        delay = 0;\r\n        sfx = yield Promise.all(entitydata.sfx.map((index) => __awaiter(this, void 0, void 0, function* () { return yield new VocFile().load(yield archive.getRecord(index)); })));\r\n        return us.header;\r\n    });\r\n}\r\nfunction loadParticleScript(archive) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let entitydata = entities[entity];\r\n        let sprite = yield new wc1.Sprite(endianness).load(yield archive.getRecord(entitydata.sprite));\r\n        textures = yield sprite.makeTextures(context);\r\n        let script = yield new wc1.Script(endianness).load(yield archive.getRecord(212));\r\n        let us = script.getParticle(entitydata.script);\r\n        console.log(Object.assign({}, entitydata));\r\n        view = new DataView(us.buffer);\r\n        frame = 0;\r\n        offset = us.header.movementOffset.value;\r\n        delay = 0;\r\n        return us.header;\r\n    });\r\n}\r\nlet tileset;\r\nlet map;\r\nfunction render(ms) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        context.clear(context.COLOR_BUFFER_BIT);\r\n        updateCycle();\r\n        if (is.present(map) && is.present(tileset)) {\r\n            for (let y = 0; y < 16; y++) {\r\n                for (let x = 0; x < 16; x++) {\r\n                    context.uniform1i(transparentIndexLocation, 256);\r\n                    context.uniform2f(anchorLocation, 0.0, 0.0);\r\n                    context.uniform2f(quadLocation, x * 16, y * 16);\r\n                    context.uniform2i(scalingLocation, 0, 0);\r\n                    context.activeTexture(context.TEXTURE0);\r\n                    context.bindTexture(context.TEXTURE_2D, tileset[map[y * 64 + x]]);\r\n                    context.bindBuffer(context.ARRAY_BUFFER, buffer);\r\n                    context.drawArrays(context.TRIANGLES, 0, 6);\r\n                }\r\n            }\r\n        }\r\n        if (is.present(offset) && is.present(view)) {\r\n            if (delay > 0) {\r\n                delay -= 1;\r\n            }\r\n            else {\r\n                let opcode = view.getUint8(offset++);\r\n                if (opcode === 0) {\r\n                }\r\n                else if (opcode === 1) {\r\n                    delay = view.getUint8(offset++);\r\n                }\r\n                else if (opcode === 2) {\r\n                    throw \"\";\r\n                }\r\n                else if (opcode === 3) {\r\n                    offset = view.getUint16(offset, true);\r\n                }\r\n                else if (opcode === 4) {\r\n                    frame = view.getUint8(offset++);\r\n                }\r\n                else if (opcode === 5) {\r\n                    let movement = view.getUint8(offset++);\r\n                }\r\n                else if (opcode === 6) {\r\n                    let movement = view.getUint8(offset++);\r\n                    frame = view.getUint8(offset++);\r\n                }\r\n                else if (opcode === 7) {\r\n                    delay = view.getUint8(offset++);\r\n                }\r\n                else if (opcode === 8) {\r\n                    setTimeout(() => {\r\n                        if (sfx.length > 0) {\r\n                            sfx[Math.floor(Math.random() * sfx.length)].play();\r\n                        }\r\n                    });\r\n                }\r\n                else if (opcode === 9) {\r\n                    console.log(\"damage!\");\r\n                }\r\n                else if (opcode === 10) {\r\n                    delay = view.getUint8(offset++);\r\n                }\r\n                else {\r\n                    throw `Invalid opcode ${opcode}!`;\r\n                }\r\n            }\r\n            let index = direction < 5 ? frame + direction : frame + 8 - direction;\r\n            if (index >= textures.length) {\r\n                //console.log({index, unit: entity});\r\n            }\r\n            context.uniform1i(transparentIndexLocation, 0);\r\n            context.uniform2f(anchorLocation, 0.5, 0.5);\r\n            context.uniform2f(quadLocation, 48, 48);\r\n            context.uniform2i(scalingLocation, direction < 5 ? 0 : 1, 0);\r\n            context.activeTexture(context.TEXTURE0);\r\n            context.bindTexture(context.TEXTURE_2D, textures[index]);\r\n            context.bindBuffer(context.ARRAY_BUFFER, buffer);\r\n            context.drawArrays(context.TRIANGLES, 0, 6);\r\n        }\r\n        window.requestAnimationFrame(render);\r\n    });\r\n}\r\nwindow.requestAnimationFrame(render);\r\nwindow.addEventListener(\"keyup\", (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n    if (false) {}\r\n    else if (event.key === \"8\") {\r\n        direction = 0;\r\n    }\r\n    else if (event.key === \"9\") {\r\n        direction = 1;\r\n    }\r\n    else if (event.key === \"6\") {\r\n        direction = 2;\r\n    }\r\n    else if (event.key === \"3\") {\r\n        direction = 3;\r\n    }\r\n    else if (event.key === \"2\") {\r\n        direction = 4;\r\n    }\r\n    else if (event.key === \"1\") {\r\n        direction = 5;\r\n    }\r\n    else if (event.key === \"4\") {\r\n        direction = 6;\r\n    }\r\n    else if (event.key === \"7\") {\r\n        direction = 7;\r\n    }\r\n    if (is.present(archive)) {\r\n        try {\r\n            if (false) {}\r\n            else if (event.key === \"a\") {\r\n                offset = (yield loadUnitScript(archive)).actionOffset.value;\r\n            }\r\n            else if (event.key === \"d\") {\r\n                offset = (yield loadUnitScript(archive)).deathOffset.value;\r\n            }\r\n            else if (event.key === \"i\") {\r\n                offset = (yield loadUnitScript(archive)).idleOffset.value;\r\n            }\r\n            else if (event.key === \"m\") {\r\n                offset = (yield loadUnitScript(archive)).movementOffset.value;\r\n            }\r\n            else if (event.key === \"s\") {\r\n                offset = (yield loadUnitScript(archive)).spawnOffset.value;\r\n            }\r\n            else if (event.key === \"t\") {\r\n                offset = (yield loadUnitScript(archive)).trainOffset.value;\r\n            }\r\n            else if (event.key === \"z\") {\r\n                w;\r\n                offset = (yield loadParticleScript(archive)).spawnOffset.value;\r\n            }\r\n            else if (event.key === \"x\") {\r\n                offset = (yield loadParticleScript(archive)).movementOffset.value;\r\n            }\r\n            else if (event.key === \"c\") {\r\n                offset = (yield loadParticleScript(archive)).hitOffset.value;\r\n            }\r\n            else if (event.key === \"ArrowUp\") {\r\n                entity = (((entity - 1) % entities.length) + entities.length) % entities.length;\r\n                let ed = entities[entity];\r\n                if (ed.type === \"effect\") {\r\n                    yield loadParticleScript(archive);\r\n                }\r\n                else {\r\n                    yield loadUnitScript(archive);\r\n                }\r\n            }\r\n            else if (event.key === \"ArrowDown\") {\r\n                entity = (((entity + 1) % entities.length) + entities.length) % entities.length;\r\n                let ed = entities[entity];\r\n                if (ed.type === \"effect\") {\r\n                    yield loadParticleScript(archive);\r\n                }\r\n                else {\r\n                    yield loadUnitScript(archive);\r\n                }\r\n            }\r\n        }\r\n        catch (error) { }\r\n    }\r\n}));\r\ncanvas.addEventListener(\"drop\", (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n    event.stopPropagation();\r\n    event.preventDefault();\r\n    let dataTransfer = event.dataTransfer;\r\n    if (is.present(dataTransfer)) {\r\n        let files = dataTransfer.files;\r\n        for (let file of files) {\r\n            let dataProvider = yield new FileDataProvider(file).buffer();\r\n            yield load(dataProvider);\r\n        }\r\n    }\r\n}));\r\nfunction resize() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let w = canvas.offsetWidth * window.devicePixelRatio;\r\n        let h = canvas.offsetHeight * window.devicePixelRatio;\r\n        canvas.setAttribute(\"width\", `${w}px`);\r\n        canvas.setAttribute(\"height\", `${h}px`);\r\n        context.viewport(0, 0, w, h);\r\n        context.uniform2i(viewportLocation, w, h);\r\n    });\r\n}\r\ndocument.body.appendChild(canvas);\r\nwindow.addEventListener(\"resize\", () => {\r\n    resize();\r\n});\r\nresize();\r\n\n\n//# sourceURL=webpack://@joelek/webcraft/./build/client/index.js?");

/***/ }),

/***/ "./build/shared/index.js":
/*!*******************************!*\
  !*** ./build/shared/index.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./tables */ \"./build/shared/tables.js\"), exports);\r\n\n\n//# sourceURL=webpack://@joelek/webcraft/./build/shared/index.js?");

/***/ }),

/***/ "./build/shared/tables.js":
/*!********************************!*\
  !*** ./build/shared/tables.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.armorPiercingDamage = exports.damage = exports.armor = exports.range = exports.woodCost = exports.goldCost = exports.timeCost = exports.health = void 0;\r\n// 00288956-00289060\r\nexports.health = new Uint16Array(new Uint8Array([\r\n    0x3C, 0x00, 0x3C, 0x00, 0x28, 0x00, 0x28, 0x00,\r\n    0x78, 0x00, 0x78, 0x00, 0x5A, 0x00, 0x5A, 0x00,\r\n    0x3C, 0x00, 0x3C, 0x00, 0x28, 0x00, 0x28, 0x00,\r\n    0x28, 0x00, 0x28, 0x00, 0x96, 0x00, 0x32, 0x00,\r\n    0x28, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x3C, 0x00,\r\n    0xFA, 0x00, 0x1E, 0x00, 0x96, 0x00, 0xC8, 0x00,\r\n    0x1E, 0x00, 0x28, 0x00, 0x28, 0x00, 0x1E, 0x00,\r\n    0x2C, 0x01, 0xFA, 0x00, 0xFA, 0x00, 0xFA, 0x00,\r\n    0x90, 0x01, 0x90, 0x01, 0x20, 0x03, 0x20, 0x03,\r\n    0xBC, 0x02, 0xBC, 0x02, 0x84, 0x03, 0x84, 0x03,\r\n    0xC4, 0x09, 0xC4, 0x09, 0x58, 0x02, 0x58, 0x02,\r\n    0xF4, 0x01, 0xF4, 0x01, 0x20, 0x03, 0x20, 0x03,\r\n    0x88, 0x13, 0x88, 0x13, 0x9C, 0x63, 0xFF, 0x00\r\n]).buffer);\r\n// 00289112-00289164\r\nexports.timeCost = new Uint8Array([\r\n    0x3C, 0x3C, 0x4B, 0x4B, 0x64, 0x64, 0x50, 0x50,\r\n    0x46, 0x46, 0x5A, 0x5A, 0x50, 0x50, 0x00, 0x00,\r\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n    0x64, 0x64, 0x96, 0x96, 0xC8, 0xC8, 0xC8, 0xC8,\r\n    0x64, 0x64, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,\r\n    0xC8, 0xC8, 0x96, 0x00\r\n]);\r\n// 00289168-00289220\r\nexports.goldCost = new Uint8Array([\r\n    0x28, 0x28, 0x28, 0x28, 0x5A, 0x5A, 0x55, 0x55,\r\n    0x2D, 0x2D, 0x5A, 0x5A, 0x46, 0x46, 0xFA, 0xFA,\r\n    0xFA, 0xFA, 0xFA, 0x5A, 0x00, 0x14, 0x14, 0x96,\r\n    0x14, 0x32, 0x0A, 0x28, 0xC8, 0x00, 0x00, 0xC8,\r\n    0x32, 0x32, 0x3C, 0x3C, 0x50, 0x50, 0x8C, 0x8C,\r\n    0x28, 0x28, 0x3C, 0x3C, 0x64, 0x64, 0x5A, 0x5A,\r\n    0xFA, 0xFA, 0x00, 0x00\r\n]);\r\n// 00289224-00289276\r\nexports.woodCost = new Uint8Array([\r\n    0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x00, 0x00,\r\n    0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n    0x1E, 0x1E, 0x32, 0x32, 0x32, 0x32, 0x1E, 0x1E,\r\n    0x28, 0x28, 0x32, 0x32, 0x28, 0x28, 0x28, 0x28,\r\n    0xC8, 0xC8, 0x0A, 0x00\r\n]);\r\n// 00289712-00289744\r\nexports.range = new Uint8Array([\r\n    0x01, 0x01, 0x01, 0x01, 0x08, 0x08, 0x01, 0x01,\r\n    0x05, 0x04, 0x03, 0x02, 0x01, 0x02, 0x05, 0x01,\r\n    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03\r\n]);\r\n// 00289744-00289776\r\nexports.armor = new Uint8Array([\r\n    0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05,\r\n    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,\r\n    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0A, 0x00,\r\n    0x00, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00\r\n]);\r\n// 00289952-00289984\r\nexports.damage = new Uint8Array([\r\n    0x09, 0x09, 0x00, 0x00, 0xFF, 0xFF, 0x0D, 0x0D,\r\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,\r\n    0x00, 0x00, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x28,\r\n    0x00, 0x09, 0x04, 0x09, 0x41, 0x00, 0x00, 0x00\r\n]);\r\n// 00289984-00290016\r\nexports.armorPiercingDamage = new Uint8Array([\r\n    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,\r\n    0x04, 0x05, 0x06, 0x06, 0x06, 0x06, 0x0A, 0x01,\r\n    0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00,\r\n    0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x28\r\n]);\r\n\n\n//# sourceURL=webpack://@joelek/webcraft/./build/shared/tables.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./build/client/index.js");
/******/ })()
;